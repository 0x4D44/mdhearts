# Bot Implementation Plan — 3 October 2025

## 1. Repository Preparation
- Create `crates/hearts-app/src/bot/` module to hold planning logic (`mod.rs`, `pass.rs`, `play.rs`, etc.).
- Update `controller.rs` to depend on the new module while retaining current behaviour behind a feature flag / difficulty enum (`BotDifficulty`).
- Add `UnseenTracker` helper (struct + unit tests) in the bot module.

## 2. Data Model & Planners
1. `BotStyle`, `BotDifficulty`, `BotContext` definitions.
2. `PassPlanner::choose(hand: &Hand, ctx: &BotContext) -> [Card; 3]`.
3. `PlayPlanner::choose(legal: &[Card], ctx: &BotContext) -> Card`.
4. Style selector `determine_style(ctx) -> BotStyle` using scoreboard + round state.
5. `UnseenTracker` initialised per round; update hooks in controller when a trick completes.
6. Integrate into controller:
   - Replace `simple_pass_for` with call to planner.
   - Replace card selection in `autoplay_one` with planner (fallback to legacy for Easy difficulty).
   - Add difficulty field to `GameController` (default Neutral).

## 3. Passing Heuristics Implementation
- Card scoring function returning `f32` based on:
  - Point danger (hearts, Q♠, high spades/hearts).
  - Suit-shortening bonuses.
  - Style-based adjustments (aggressive vs cautious).
- Sorting and choosing top three; ensure deterministic tie-breaking.
- Helper to evaluate moon potential (counts hearts, control cards) to flip to aggressive passing.

## 4. Trick Play Heuristics Implementation
- For each legal card compute features:
  - Trick winner (uses perfect info via `RoundState` and `Trick::winner`).
  - Points carried (hearts, Q♠).
  - Void creation (hand size after play).
  - Hearts-breaking check.
  - Scoreboard incentives (dump on opponent ≥ 90, protect self ≥ 90).
- Style-specific weighting & final score.
- Mid-round moon tracking: if we already captured many points and retain control, switch to aggressive until moon attempt fails.
- Ensure final decision is deterministic for given context (no randomness for now).

## 5. Controller Wiring & Difficulty Toggle
- Add enum `BotDifficulty { EasyLegacy, NormalHeuristic, FutureHard }`.
- Default to `NormalHeuristic` for AI seats; retain legacy simple logic when `EasyLegacy` selected (useful for regression).
- Expose difficulty selection via CLI flag/env var (e.g., `MDH_BOT_DIFFICULTY=easy|normal|hard`).

## 6. Automated Tests
### Unit Tests (Rust)
- `pass.rs`:
  - `cautious_pass_drops_q_spades` (fixture hand verifies top choices).
  - `aggressive_pass_keeps_control_cards` (moon candidate).
  - `pass_prefers_void_creation` (exactly three diamonds → all passed).
- `play.rs`:
  - `cautious_dumps_points_when_safe` (opponent guaranteed to win trick).
  - `cautious_avoids_capturing_points` (choose non-winning card when trick has hearts).
  - `aggressive_captures_points_for_moon` (moon attempt scenario).
  - `endgame_targets_leader` (opponent ≥90 gets forced points).
- `unseen_tracker.rs`:
  - `tracker_updates_after_trick` ensures counts drop appropriately.

### Integration Tests (hearts-app)
- Simulate scripted round with known hands verifying autoplayer leads expected sequences (use deterministic deck seed).
- End-to-end game run under `cargo test` to assert no panics and scoreboard update consistent with expected totals.

## 7. Instrumentation & Debugging
- Add optional `MDH_DEBUG_LOGS=1` output for decisions (card scores, chosen style).
- Provide helper to dump `BotContext` when an assert/test fails.

## 8. Documentation & Config
- Update `designs` doc with final notes once implemented.
- Document new env variables / difficulty selection in README.

## 9. Rollout Steps
1. Implement modules + planners + unit tests.
2. Integrate into controller with difficulty toggle.
3. Run full `cargo fmt`, `cargo clippy`, `cargo test`, and manual play session.
4. Update documentation and submit PR.
