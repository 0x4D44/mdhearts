# AI Difficulty Selection Design

**Date**: 2025-10-11
**Status**: Proposed
**Priority**: Medium (Usability Improvement)

## Problem Statement

Users currently have no way to select AI difficulty from within the game:
- **Environment variable only**: Must set `MDH_BOT_DIFFICULTY=easy/normal/hard` before launching
- **No BC model access**: Behavioral Cloning model exists but cannot be selected from UI
- **No feedback**: User doesn't know current AI difficulty level
- **Requires restart**: Changing difficulty requires closing and restarting the game

## Requirements

1. **In-Game Selection**: Choose AI difficulty from menu without restarting
2. **BC Model Support**: Allow selecting Behavioral Cloning model as AI opponent
3. **Persistence**: Remember user's choice across sessions
4. **Visual Feedback**: Show current selection with checkmark
5. **Immediate Effect**: Apply to next game (Game > New)

## Proposed Design

### Menu Structure

Add submenu under **Options**:

```
Options
  ├── AI Player
  │   ├── ○ Easy
  │   ├── ● Normal (default)
  │   ├── ○ Hard
  │   └── ○ Behavioral Cloning (Hard-level)
  └── Card Back
      ├── ○ Classic
      └── ...
```

**Radio button behavior**: Checkmark (●) next to currently selected option

### AI Options

| Option | Description | Backend |
|--------|-------------|---------|
| **Easy** | Legacy simple AI | `BotDifficulty::EasyLegacy` |
| **Normal** | Heuristic planner (default) | `BotDifficulty::NormalHeuristic` |
| **Hard** | Advanced heuristics | `BotDifficulty::FutureHard` |
| **Behavioral Cloning** | Trained AI model (~Hard level) | Load `ai_training/bc/bc_hard_20ep_10k.json` |

### User Experience Flow

1. User opens **Options > AI Player** submenu
2. Sees current selection marked with ●
3. Clicks desired difficulty (e.g., "Hard")
4. Setting is saved to registry
5. Next time user clicks **Game > New**, new match uses selected difficulty

**Note**: Changing difficulty does NOT affect current game, only future games.

## Implementation Plan

### 1. Add Menu IDs (win32.rs)

```rust
const ID_GAME_NEW: u32 = 1001;
const ID_GAME_RESTART: u32 = 1002;
const ID_GAME_EXIT: u32 = 1003;

// Add these:
const ID_AI_EASY: u32 = 1101;
const ID_AI_NORMAL: u32 = 1102;
const ID_AI_HARD: u32 = 1103;
const ID_AI_BC: u32 = 1104;

const ID_OPTIONS_CARD_BACK: u32 = 1201;
const ID_HELP_ABOUT: u32 = 1301;
const ID_HELP_RULES: u32 = 1302;
```

### 2. Create AI Selection Menu

In `init_menu_and_accels()`:

```rust
// Create AI Player submenu
let ai_menu = unsafe { CreatePopupMenu()? };
unsafe {
    AppendMenuW(ai_menu, MF_STRING, ID_AI_EASY as usize, w!("Easy"))?;
    AppendMenuW(ai_menu, MF_STRING, ID_AI_NORMAL as usize, w!("Normal"))?;
    AppendMenuW(ai_menu, MF_STRING, ID_AI_HARD as usize, w!("Hard"))?;
    AppendMenuW(ai_menu, MF_SEPARATOR, 0, PCWSTR::null())?;
    AppendMenuW(ai_menu, MF_STRING, ID_AI_BC as usize, w!("Behavioral Cloning (Hard-level)"))?;
}

// Attach to Options menu
unsafe {
    AppendMenuW(options_menu, MF_POPUP, ai_menu.0 as usize, w!("AI &Player"))?;
    AppendMenuW(options_menu, MF_POPUP, card_back_menu.0 as usize, w!("&Card Back"))?;
}
```

### 3. Registry Persistence

Add functions similar to `load_card_back()` / `save_card_back()`:

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum AiSelection {
    Easy,
    Normal,
    Hard,
    BehavioralCloning,
}

impl AiSelection {
    fn to_u32(self) -> u32 {
        match self {
            AiSelection::Easy => 0,
            AiSelection::Normal => 1,
            AiSelection::Hard => 2,
            AiSelection::BehavioralCloning => 3,
        }
    }

    fn from_u32(value: u32) -> Option<Self> {
        match value {
            0 => Some(AiSelection::Easy),
            1 => Some(AiSelection::Normal),
            2 => Some(AiSelection::Hard),
            3 => Some(AiSelection::BehavioralCloning),
            _ => None,
        }
    }
}

fn load_ai_selection() -> Option<AiSelection> {
    // Read from registry: HKEY_CURRENT_USER\Software\MDHearts\AiSelection
    let mut value: u32 = 0;
    let mut size: u32 = std::mem::size_of::<u32>() as u32;

    unsafe {
        let mut hkey = HKEY::default();
        if RegOpenKeyExW(
            HKEY_CURRENT_USER,
            w!("Software\\MDHearts"),
            0,
            KEY_READ,
            &mut hkey,
        ).is_ok() {
            let result = RegGetValueW(
                hkey,
                PCWSTR::null(),
                w!("AiSelection"),
                RRF_RT_REG_DWORD,
                None,
                Some(&mut value as *mut u32 as *mut _),
                Some(&mut size),
            );
            let _ = RegCloseKey(hkey);
            if result.is_ok() {
                return AiSelection::from_u32(value);
            }
        }
    }
    None
}

fn save_ai_selection(selection: AiSelection) {
    unsafe {
        let mut hkey = HKEY::default();
        let mut _disp: u32 = 0;
        if RegCreateKeyExW(
            HKEY_CURRENT_USER,
            w!("Software\\MDHearts"),
            0,
            PCWSTR::null(),
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            None,
            &mut hkey,
            Some(&mut _disp),
        ).is_ok() {
            let value = selection.to_u32();
            let _ = RegSetValueExW(
                hkey,
                w!("AiSelection"),
                0,
                REG_DWORD,
                Some(&value.to_ne_bytes()),
            );
            let _ = RegCloseKey(hkey);
        }
    }
}
```

### 4. Update AppState

Add field to track current AI selection:

```rust
struct AppState {
    // ... existing fields
    ai_selection: AiSelection,
}

impl AppState {
    fn new() -> Result<Self> {
        // ...
        let ai_selection = load_ai_selection().unwrap_or(AiSelection::Normal);

        let controller = Self::create_controller(ai_selection)?;

        // ...
        Ok(Self {
            // ...
            controller,
            ai_selection,
            // ...
        })
    }

    fn create_controller(ai_selection: AiSelection) -> Result<GameController> {
        match ai_selection {
            AiSelection::Easy => {
                let mut controller = GameController::new_with_seed(None, PlayerPosition::North);
                controller.set_bot_difficulty(BotDifficulty::EasyLegacy);
                Ok(controller)
            }
            AiSelection::Normal => {
                let mut controller = GameController::new_with_seed(None, PlayerPosition::North);
                controller.set_bot_difficulty(BotDifficulty::NormalHeuristic);
                Ok(controller)
            }
            AiSelection::Hard => {
                let mut controller = GameController::new_with_seed(None, PlayerPosition::North);
                controller.set_bot_difficulty(BotDifficulty::FutureHard);
                Ok(controller)
            }
            AiSelection::BehavioralCloning => {
                // Create controller with BC model
                Self::create_bc_controller()
            }
        }
    }

    fn create_bc_controller() -> Result<GameController> {
        // TODO: Need to add support for embedded policy to GameController
        // For now, fall back to Hard
        let mut controller = GameController::new_with_seed(None, PlayerPosition::North);
        controller.set_bot_difficulty(BotDifficulty::FutureHard);
        Ok(controller)
    }
}
```

### 5. Handle Menu Commands

In `wndproc()`, `WM_COMMAND` handler:

```rust
match id {
    ID_GAME_NEW => {
        // Recreate controller with current AI selection
        let controller = AppState::create_controller(state.ai_selection)?;
        state.controller = controller;
        state.passing_select.clear();
        unsafe {
            let _ = InvalidateRect(Some(hwnd), None, true);
        }
    }

    ID_AI_EASY => {
        state.ai_selection = AiSelection::Easy;
        save_ai_selection(AiSelection::Easy);
        // Don't change current game, only affects next "New Game"
    }
    ID_AI_NORMAL => {
        state.ai_selection = AiSelection::Normal;
        save_ai_selection(AiSelection::Normal);
    }
    ID_AI_HARD => {
        state.ai_selection = AiSelection::Hard;
        save_ai_selection(AiSelection::Hard);
    }
    ID_AI_BC => {
        state.ai_selection = AiSelection::BehavioralCloning;
        save_ai_selection(AiSelection::BehavioralCloning);
    }

    // ... existing handlers
}
```

### 6. Update Menu Checkmarks

Need to refresh menu checkmarks when menu opens. In WM_INITMENUPOPUP or use CheckMenuItem:

```rust
fn update_ai_menu_checks(menu: HMENU, current: AiSelection) {
    unsafe {
        CheckMenuItem(menu, ID_AI_EASY, MF_UNCHECKED);
        CheckMenuItem(menu, ID_AI_NORMAL, MF_UNCHECKED);
        CheckMenuItem(menu, ID_AI_HARD, MF_UNCHECKED);
        CheckMenuItem(menu, ID_AI_BC, MF_UNCHECKED);

        let check_id = match current {
            AiSelection::Easy => ID_AI_EASY,
            AiSelection::Normal => ID_AI_NORMAL,
            AiSelection::Hard => ID_AI_HARD,
            AiSelection::BehavioralCloning => ID_AI_BC,
        };
        CheckMenuItem(menu, check_id, MF_CHECKED);
    }
}
```

## BC Model Support Challenge

**Problem**: GameController currently only supports BotDifficulty (heuristic policies), not EmbeddedPolicy.

**Options**:

### Option A: Extend GameController (Simple)
Add BC as a special difficulty:

```rust
// In controller.rs
pub enum AiMode {
    Heuristic(BotDifficulty),
    Embedded(String), // path to weights
}

pub struct GameController {
    ai_mode: AiMode,
    // ... rest
}
```

Then in autoplay_one, choose_pass, etc., branch on ai_mode.

**Pros**: Minimal changes
**Cons**: Duplicates policy logic in controller

### Option B: Use Box<dyn Policy> (Clean)
Refactor GameController to hold policies directly:

```rust
pub struct GameController {
    policies: [Box<dyn Policy>; 4], // One for each seat
    // ... rest
}
```

**Pros**: Clean architecture, no duplication
**Cons**: Larger refactor

### Option C: BC as Hard with Override (Pragmatic)
Keep it simple for v1:
- Menu shows "Behavioral Cloning" option
- When selected, still creates HeuristicPolicy::hard()
- Add note in UI: "BC model coming soon!"

**Pros**: Can ship menu immediately
**Cons**: Doesn't actually use BC model yet

## Recommended Implementation Order

**Phase 1: Basic Menu (1-2 hours)**
- Add menu structure with Easy/Normal/Hard
- Add registry persistence
- Update controller creation
- Test difficulty switching

**Phase 2: BC Integration (2-3 hours)**
- Choose Option A or B for BC support
- Add BC model loading
- Test BC model in gameplay

## Alternative: Simple Dialog

Instead of menu, could add **Options > Settings...** dialog with:
- Radio buttons for AI difficulty
- Card back dropdown
- Other future settings

**Pros**: Easier to add more settings later
**Cons**: More work upfront

## Testing Plan

### Manual Tests
1. Start game → Should use Normal (default)
2. Change to Easy → New Game → Verify easy AI behavior
3. Change to Hard → New Game → Verify hard AI behavior
4. Restart game → Verify saved selection persists
5. (Phase 2) Change to BC → New Game → Verify BC model loads

### Edge Cases
- Registry read fails → Fall back to Normal
- BC weights file missing → Show error, fall back to Hard
- Changing difficulty mid-game → Should not crash, affects next game only

## Success Criteria

- ✅ User can select AI difficulty from menu
- ✅ Selection persists across restarts
- ✅ Current selection shown with checkmark
- ✅ Changes apply to next "New Game"
- ✅ BC model option available (even if not fully working in Phase 1)
- ✅ No crashes or errors

## Future Enhancements

- **Per-seat difficulty**: Different AI for each opponent
- **Custom BC models**: Browse for .json weight files
- **AI settings dialog**: Unified place for all AI config
- **AI performance stats**: Track win rates by difficulty
