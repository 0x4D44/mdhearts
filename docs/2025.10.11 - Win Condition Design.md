# Win Condition Implementation Design

**Date**: 2025-10-11
**Status**: Not Implemented
**Priority**: High (Core Game Feature Missing)

## Problem Statement

The game currently has **no win condition**. After each round completes, it automatically starts a new round indefinitely. According to the rules text (win32.rs:2360), the match should end when any player reaches 100 points, with the lowest score winning.

**Current Behavior:**
- Game loops through rounds forever (Round 1 → Round 2 → Round 3 → ...)
- No detection of 100+ point threshold
- No winner announcement
- No game-over state

## Requirements

1. **End Condition**: Match ends when any player reaches 100+ points after scoring a round
2. **Winner Determination**: Player with the **lowest** score wins (Hearts is a low-score game)
3. **UI Feedback**: Display winner and final scores
4. **User Actions**: Allow starting a new match after game over

## Design

### 1. Core Model Changes (`hearts-core/src/game/match_state.rs`)

Add match completion detection:

```rust
impl MatchState {
    /// Check if match is complete (any player has 100+ points)
    pub fn is_match_complete(&self) -> bool {
        self.scores.standings().iter().any(|&score| score >= 100)
    }

    /// Get winner (player with lowest score when match is complete)
    /// Returns None if match is not complete
    pub fn winner(&self) -> Option<PlayerPosition> {
        if !self.is_match_complete() {
            return None;
        }

        let standings = self.scores.standings();
        let min_score = standings.iter().min()?;

        PlayerPosition::LOOP.iter().copied().find(|&pos| {
            self.scores.score(pos) == *min_score
        })
    }

    /// Get final standings as (position, score) sorted by score
    pub fn final_standings(&self) -> Vec<(PlayerPosition, u32)> {
        let mut results: Vec<_> = PlayerPosition::LOOP.iter()
            .map(|&pos| (pos, self.scores.score(pos)))
            .collect();
        results.sort_by_key(|(_, score)| *score);
        results
    }
}
```

**Note**: Do NOT modify `finish_round_and_start_next()`. It should continue to just score and start next round. The check should happen in the controller/UI layer.

### 2. Controller Changes (`hearts-app/src/controller.rs`)

Add convenience methods:

```rust
impl GameController {
    pub fn is_match_complete(&self) -> bool {
        self.match_state.is_match_complete()
    }

    pub fn winner(&self) -> Option<PlayerPosition> {
        self.match_state.winner()
    }

    pub fn final_standings(&self) -> Vec<(PlayerPosition, u32)> {
        self.match_state.final_standings()
    }

    /// Start a completely new match (reset scores, round 1)
    pub fn start_new_match(&mut self) {
        let starting = self.match_state.round().starting_player();
        *self = Self::new_with_seed(None, starting);
    }
}
```

### 3. UI Changes (`hearts-app/src/platform/win32.rs`)

#### 3.1 Add Game State Tracking

```rust
enum GamePhase {
    Passing,
    Playing,
    RoundComplete,     // Show round scores, "Next Round" button
    MatchComplete,     // Show final standings, "New Game" button
}

struct AppState {
    game_phase: GamePhase,
    // ... existing fields
}
```

#### 3.2 Modify Round Completion Flow

**Current flow (after trick animation completes):**
```
Trick completes → Show round scores → Auto-start next round
```

**New flow:**
```
Trick completes → controller.finish_round_if_ready()
                → Check if match complete
                → If yes: game_phase = MatchComplete (show winner dialog)
                → If no: game_phase = RoundComplete (show scores, "Next Round" button)
```

#### 3.3 Add Winner Dialog

Create a modal dialog similar to the "About" dialog:

```rust
fn show_winner_dialog(hwnd: HWND, winner: PlayerPosition, standings: &[(PlayerPosition, u32)]) {
    let message = format!(
        "Match Complete!\n\n\
         Winner: {}\n\n\
         Final Scores:\n\
         {} - {} points\n\
         {} - {} points\n\
         {} - {} points\n\
         {} - {} points\n\n\
         Start a new match?",
        winner,
        standings[0].0, standings[0].1,
        standings[1].0, standings[1].1,
        standings[2].0, standings[2].1,
        standings[3].0, standings[3].1,
    );

    // MessageBox with YES/NO buttons
    // YES → controller.start_new_match()
    // NO → Keep showing final scores
}
```

#### 3.4 Prevent Actions During Match Complete

When `game_phase == MatchComplete`:
- ❌ Block card plays
- ❌ Block "Restart Round" menu option
- ✅ Allow "New Game" menu option
- ✅ Show winner in status bar: "Match Complete - North wins!"

### 4. Edge Cases

#### Tie Handling
If multiple players have the lowest score:
- **Option 1**: Declare all tied players as winners
- **Option 2**: Continue playing until tie is broken
- **Recommended**: Option 1 (simpler, matches Microsoft Hearts behavior)

#### Moonshot on Final Round
If a player shoots the moon on the final round and this causes scores to cross 100:
- ✅ Match ends (someone crossed 100)
- ✅ Winner is determined by final scores after moonshot is applied

#### Mid-Round State
The check should only happen **after** a round is scored, not during play. Use existing `finish_round_if_ready()` as the checkpoint.

## Implementation Order

1. **Phase 1: Core Model** (hearts-core)
   - Add `is_match_complete()`, `winner()`, `final_standings()` to MatchState
   - Write unit tests for edge cases (ties, moonshots, exact 100)

2. **Phase 2: Controller** (hearts-app/controller.rs)
   - Add passthrough methods
   - Add `start_new_match()` method
   - Write tests

3. **Phase 3: UI** (hearts-app/platform/win32.rs)
   - Add GamePhase enum
   - Modify round completion flow to check for match complete
   - Add winner dialog
   - Block actions during match complete
   - Update status bar

4. **Phase 4: Testing**
   - Manual test: Play until 100+ points reached
   - Test tie scenarios
   - Test moonshot on final round
   - Test "New Game" restarts properly

## Testing Strategy

### Unit Tests
```rust
#[test]
fn match_completes_when_player_reaches_100() {
    let mut match_state = MatchState::new(PlayerPosition::North);
    match_state.scores_mut().set_score(PlayerPosition::South, 105);
    assert!(match_state.is_match_complete());
}

#[test]
fn winner_is_lowest_score_when_complete() {
    let mut match_state = MatchState::new(PlayerPosition::North);
    match_state.scores_mut().set_score(PlayerPosition::North, 105);
    match_state.scores_mut().set_score(PlayerPosition::South, 87);
    match_state.scores_mut().set_score(PlayerPosition::East, 92);
    match_state.scores_mut().set_score(PlayerPosition::West, 98);

    assert_eq!(match_state.winner(), Some(PlayerPosition::South));
}

#[test]
fn match_not_complete_under_100() {
    let mut match_state = MatchState::new(PlayerPosition::North);
    match_state.scores_mut().set_score(PlayerPosition::North, 99);
    assert!(!match_state.is_match_complete());
}
```

### Manual Tests
1. Fast-track test: Use debugger to set scores to 95+ and play one more round
2. Tie test: Set all players to 95, ensure proper handling
3. Moonshot test: Set players near 100, shoot moon to trigger end

## Alternative Designs Considered

### Auto-restart After Winner Shown
**Rejected**: User should explicitly choose to start new game

### Configurable Point Threshold
**Deferred**: Could add settings for 50/100/150 point limits, but not needed for MVP

### Match Statistics Tracking
**Deferred**: Could track wins/losses across matches, but not in this design

## Success Criteria

- ✅ Game ends when any player reaches 100+ points
- ✅ Winner is correctly identified (lowest score)
- ✅ Winner dialog displays final standings
- ✅ User can start new match
- ✅ No crashes or UI glitches during transition
- ✅ All unit tests pass
- ✅ Manual testing validates all scenarios

## Estimated Effort

- Core model changes: **30 minutes**
- Controller changes: **15 minutes**
- UI changes: **2-3 hours** (most complex, involves state management)
- Testing: **1 hour**
- **Total: ~4-5 hours**

## References

- Rules text: `crates/hearts-app/src/platform/win32.rs:2360`
- Microsoft Hearts rules: https://en.wikipedia.org/wiki/Microsoft_Hearts
- Current match state code: `crates/hearts-core/src/game/match_state.rs`
