# Stage 3 HLD — Search-lite & Endgame Solver (SEARCH-300, END-400, INST-500 completion)

## Overview
- Layer bounded lookahead on top of Stage 1 beliefs to evaluate moves via sampled worlds.
- Provide exact resolution for late-hand scenarios (≤6 cards per player) to improve endgame accuracy.
- Close out instrumentation work with latency guardrails, sampled-world rationale logs, and graceful fallbacks.

## Goals
- Implement `evaluate_moves` that samples K belief-consistent worlds, runs depth-2/3 maxn or paranoid search, and returns scored moves with uncertainty metrics.
- Build an endgame solver that enumerates or aggressively samples all consistent worlds when cards remaining per player ≤ 6, solving to hand completion.
- Enforce per-move time budgets and log usage; ensure fallback to heuristic planner when resources exhausted.
- Demonstrate PPH reduction vs. heuristic-only baseline within configured latency threshold.

## Non-Goals
- Full RIS-/GO-MCTS integration (future Stage 4+).
- Revisiting belief updates (Stage 1 covers base accuracy; Stage 3 consumes the API).
- Adjusting behavioral cloning policies (Stage 4 handles dataset alignment).

## Architecture
- `crates/hearts-core/src/search/`:
  - `cfg.rs`: `SearchCfg { worlds: u32, depth: u8, beta: f32, time_budget_ms: u32, paranoid_threshold: f32 }`.
  - `world_sampler.rs`: wraps Stage 1 sampler with caching, ensures deterministic ordering under fixed seed.
  - `lookahead.rs`: core maxn/paranoid evaluation with heuristic rollouts.
  - `rollout_policy.rs`: biased playout rules (e.g., avoid early point collection, protect shooter).
  - `scored_moves.rs`: data structure carrying score, variance, supporting reason strings.
- `crates/hearts-core/src/endgame/`:
  - `solver.rs`: performs exact search using alpha-beta or memoized maxn when state size small.
  - `world_enumerator.rs`: enumerates remaining hands honoring beliefs (fallback to sampling if combinatorial explosion).
- `crates/hearts-app/src/bot/planner.rs`:
  - Orchestrates heuristic vs. search-lite decision pathway based on time budget and phase of hand.
- Instrumentation (INST-500 completion):
  - `SearchLog { trick_idx, move, expected_points, variance, sampled_worlds, duration_ms }`.
  - `EndgameLog { cards_left, strategy, nodes_expanded, result }`.
  - Time budget tracker publishing `budget_exceeded` warnings.

## Search-lite Flow
1. Build move list of legal cards.
2. For each move:
   - Draw K worlds from belief cache; reuse sibling worlds where possible.
   - For each world, simulate depth-2/3 lookahead:
     - Use `paranoid` when moon probability or coalition objective active; otherwise `maxn`.
     - At leaves, apply biased rollout policy to complete remaining tricks quickly.
   - Aggregate expected points, confidence intervals, and objective-aware utility `U = -E[points] + β·E(leader_next - me_next)`.
3. Rank moves; apply tie-breaking by variance and heuristic priors.
4. Respect `time_budget_ms` using per-move timers; if exceeded, truncate evaluation and fall back to heuristic scoring with warning log.

## Rollout Policy
- Derived from heuristics but parameterized:
  - Avoid playing Q♠ unless forced.
  - Feed points to coalition targets when objective is `BlockShooter`.
  - Prefer shedding suits where belief confidence high for opponents voiding.
- Configurable via `search_rollout.yaml`; tuned later using Stage 0 harness.

## Endgame Solver
- Trigger when `cards_left_per_player <= 6` or cumulative unseen states < 10^5.
- Steps:
  - Enumerate all belief-consistent worlds; if count > threshold (e.g., 512), fall back to weighted sampling.
  - For each world, run exact maxn to terminal state, caching results by `(world_hash, trick_state)`.
  - Combine per-world outcomes weighted by belief probabilities to compute move scores.
  - If solver detects guaranteed outcome (e.g., forced loss prevention), emit `EndgameDecision::Forced`.
- Provide fallback to search-lite when enumeration fails to converge within budget.

## Time Budget & Fallbacks
- Introduce `MoveBudget` struct capturing `start_time`, `allocated_ms`, `consumed_ms`.
- Enforce budgets via deadline checks within sampling loop; use cooperative cancellation to keep latency predictable.
- On budget breach:
  - Emit `budget_exceeded` telemetry with counts.
  - Return best-evaluated move so far; annotate reason in `ScoredMove.note`.
- Supply configuration defaults: `time_budget_ms = 900` for desktop, `analysis` mode override allowing up to 5000 ms (Stage 4 hook).

## Integration Points
- Heuristic planner becomes fallback and initial prior: start with heuristic score, refine via search-lite adjustments.
- Stage 2 objective (BlockShooter) influences evaluation by flipping to paranoid search and adjusting payoff function.
- Stage 1 belief cache shared via weak references to avoid recalculation overhead, with LRU eviction per deal.

## Testing Strategy
- Unit tests for `SearchCfg`, world caching, and rollout policy deterministic behavior.
- Golden tests: fixed seed, sample 32 worlds, assert final move order matches snapshot (stored in `tests/data/search-lite/*.ron`).
- Endgame solver correctness: compare results against perfect-information solver for curated positions.
- Performance regression: benchmark move evaluation on representative states, ensuring average runtime stays within budget (< 900 ms on desktop release build).
- Harness validation: Stage 0 benchmark with search-lite enabled vs. heuristic-only, verifying PPH improvements and latency logging.

## Risks & Mitigations
- **Latency spikes**: Introduce guard rails (budget enforcement, dynamic world count reduction) and emit alerts when thresholds exceeded.
- **Sampler quality**: Monitor variance and fallback to more worlds when high uncertainty detected; store adaptive `K` logic.
- **Complexity creep**: Keep depth limited (2/3) and ensure rollout policy remains lightweight; postpone deeper search to analysis mode.
- **Cache blow-up**: Cap per-deal cached worlds; reuse hash key quantization to avoid storing near-duplicates.

## Acceptance Alignment
- Search-lite demonstrates measurable PPH gains with latency staying within configured budgets in Stage 0 harness runs.
- Endgame solver succeeds on curated suites and triggers automatically at low card counts.
- Telemetry logs world counts, variance, and budget usage enabling future tuning.
