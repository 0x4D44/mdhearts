# Thinking Indicators and Timeout Refresh

## Background
- Recent hard-AI tuning pushed `GameController::autoplay_one` to run for tens of seconds, freezing the Win32 UI thread.
- The Win32 front end only shows static round metadata in the header (`crates/hearts-app/src/platform/win32.rs:1608-1650`) and keeps the default arrow cursor during long bot moves.
- WM_TIMER still executes `autoplay_one` synchronously (`crates/hearts-app/src/platform/win32.rs:2249-2328`), so there is no progress reporting or deadline enforcement.

## Goals
- Provide immediate visual feedback (wait cursor plus text) whenever a bot is thinking.
- Update the bottom hint bar so it reads "North is thinking... <elapsed>s" and counts up while the AI runs.
- Enforce a configurable think-time limit (default 10 seconds) exposed through a Win32 options submenu.
- Keep UI responsiveness by moving expensive bot evaluation off the UI thread without changing animations or human interaction.

## Non-Goals
- Replacing planner heuristics beyond cancellation plumbing.
- Altering pass or trick animations once a decision is made.
- Persisting unrelated UI settings (card backs and difficulty already handled elsewhere).

## Review Findings and Remedies
1. Hint bar messaging was omitted even though the user specifically called out that surface. **Fix:** dedicate a section for hint text updates and ensure both header and hint respond to thinking/timeout state.
2. No cancellation story existed for in-flight thinking when the user restarts, exits, or otherwise invalidates the state. **Fix:** add a central `cancel_thinking` helper invoked from the WM_COMMAND paths and WM_DESTROY.
3. The worker contract did not define a result payload, making timeout handling ambiguous. **Fix:** introduce an explicit `BotThinkResult` struct carrying the chosen card, elapsed time, timeout flag, and fallback reason.
4. Planner cancellation was hand-wavy and could miss deep loops. **Fix:** map the exact loops in `PlayPlanner` and `PlayPlannerHard` that must consult a cancel token and absolute deadline.
5. The draft used non-ASCII glyphs (smart quotes, ellipsis) that DirectWrite renders inconsistently with the current font. **Fix:** standardise on plain ASCII punctuation and explicitly call it out for the UI strings.
6. The design referenced `crossbeam_channel` without noting the extra dependency. **Fix:** switch to `std::sync::mpsc`, which is already available.
7. `ThinkConfig` carried an unused `require_wait_cursor` flag. **Fix:** drop the field to avoid confusion and keep the config tight.

## Detailed Design

### 1. Worker Lifecycle (AppState)
- Extend `AppState` (`crates/hearts-app/src/platform/win32.rs:437`) with:
  - `thinking: Option<ThinkingState>`.
  - Cached cursor handles: `cursor_arrow` and `cursor_wait`.
  - `timeout_banner: Option<TimeoutBanner>` to remember the last timed-out seat for messaging.
- `ThinkingState` fields:
  - `seat: PlayerPosition`.
  - `started_at: Instant`.
  - `deadline: Instant` (computed from `started_at + config.max_duration` when non-zero).
  - `handle: Option<std::thread::JoinHandle<()>>`.
  - `rx: std::sync::mpsc::Receiver<BotThinkResult>` (single message).
  - `cancel: Arc<AtomicBool>`.
- `AppState::start_thinking_if_needed(hwnd)` (invoked from WM_TIMER):
  1. Return early if any of the following are true: in passing phase, `anim`, `collect`, or `pass` animations active, awaiting pass acknowledgement, `thinking.is_some()`, or `controller.expected_to_play()` equals `PlayerPosition::South` (human seat).
  2. Call `controller.prepare_bot_think(bot_seat)`; if it returns `None`, exit.
  3. Create an `Arc<AtomicBool>` cancel flag, an `mpsc::channel`, and spawn `BotThinkWorker::run` with the request, cancel flag, and transmitter.
  4. Store `ThinkingState { seat, started_at, deadline, handle: Some(join_handle), rx, cancel }` and immediately `InvalidateRect` so the first frame shows "...0s".
- WM_TIMER behaviour while `thinking` is active:
  - Poll `rx.try_recv()` each tick; on message, take the handle, `join()` (the worker already exited), clear `thinking`, and hand the result to `handle_bot_result` (see Section 3).
  - If `config.max_duration` is non-zero and `Instant::now() >= deadline` with no result, set `cancel.store(true, Ordering::Relaxed)` and remember `timeout_banner = Some(TimeoutBanner { seat, triggered_at: Instant::now() })`. Continue polling next tick; if the worker still has not responded within one additional tick, log and drop the handle without joining.
  - After any check, call `InvalidateRect` so elapsed seconds and cursor stay fresh.
- Cancellation entry points: `cancel_thinking(reason)` should be called before executing New Game, Restart Round, Exit, Difficulty change, and from WM_DESTROY. The helper sets the cancel flag, waits up to three WM_TIMER ticks for a result, then logs if the worker failed to exit.

### 2. Controller and Snapshot API
- Introduce `ThinkConfig` in `GameController` (`crates/hearts-app/src/controller.rs`) with fields:
  - `max_duration: Duration` (0 = unlimited).
  - `fallback: TimeoutFallback` (enum described below).
- Provide `think_config(&self) -> ThinkConfig` and `set_think_config(&mut self, ThinkConfig)`;
  the UI stores the config within `AppState` and calls the setter when the menu changes.
- Define `TimeoutFallback` enum with variants:
  - `HeuristicBest` (use the best candidate returned before timeout).
  - `FirstLegal` (use the first legal card if nothing returned).
  - `SkipAndLog` (no automatic play; log and leave the UI to wait for a manual resolution). Default is `HeuristicBest`.
- Add `BotThinkRequest`:
  - `seat: PlayerPosition`.
  - `legal: Vec<Card>`.
  - `enforce_two: bool` (Two of Clubs rule).
  - `difficulty: BotDifficulty`.
  - `snapshot: BotSnapshot` (cloned `MatchState`, `ScoreBoard`, `UnseenTracker` trimmed to needed data).
  - `config: ThinkConfig`.
- `BotSnapshot::make_thread_local()` clones `UnseenTracker` and swaps the shared belief-cache `Arc` with a local instance so worker threads do not race on cache statistics.
- `GameController::prepare_bot_think(&self, seat)`:
  - Returns `None` for human seat, passing phase, no legal cards, or if `seat != expected_to_play()` to guard against stale timers.
  - Builds `BotThinkRequest` with fresh snapshot.
- `BotThinkResult` (worker payload):
  - `seat: PlayerPosition`.
  - `chosen: Option<Card>` (may be `None` if planner timed out before a choice).
  - `elapsed: Duration`.
  - `timed_out: bool`.
  - `fallback_used: Option<TimeoutFallback>` (populated by the UI when applying the result so telemetry knows the path).
- `handle_bot_result(result)` inside `AppState`:
  1. If `result.seat != controller.expected_to_play()`, discard and log (game was reset while thinking).
  2. Determine the card:
     - Use `result.chosen` if `Some`.
     - Else, consult `controller.think_config().fallback`:
       - `HeuristicBest`: if planner supplied `None`, fall back to first legal card from snapshot.
       - `FirstLegal`: choose first legal card from a new call to `controller.legal_moves`.
       - `SkipAndLog`: show a warning in hint text and leave the trick unresolved; the timer stops until the user acts (manual play or adjust difficulty).
  3. Call `controller.play(seat, card)` and reuse the existing animation pipeline by enqueuing `PlayAnim` as today.
  4. Record `timeout_banner` when `result.timed_out` or when the fallback path executed, so the next draw call can show "Timed out, playing safe card" once.

### 3. Worker Execution
- `BotThinkWorker::run(request, cancel, tx)` steps:
  1. Build a lightweight `WorkerController` from `request.snapshot` that exposes helpers for `BotContext` without touching the real UI state.
  2. Create `ThinkDeadline` containing `cancel`, `deadline` (Option<Instant>), and helper methods `expired()` / `remaining_ms()`.
  3. Depending on `request.difficulty`:
     - `SearchLookahead`: call `PlayPlannerHard::choose_with_deadline(&legal, &ctx, deadline)`.
     - Other difficulties: call `PlayPlanner::choose_with_deadline(&legal, &ctx, deadline)`.
  4. Measure elapsed time and build `BotThinkResult { seat, chosen, elapsed, timed_out: deadline.was_exceeded(), fallback_used: None }`.
  5. Send through `tx.send(result)`; no retry loop needed because the channel is synchronous and the UI owns the receiver.
  6. Worker returns; the UI thread `join()`s only after the message is delivered.

### 4. Planner Integration
- `PlayPlanner::choose_with_deadline`:
  - Early-return `None` if `deadline.expired()` before iteration.
  - Inside the loop over legal cards (currently around `crates/hearts-app/src/bot/play.rs:55-170`), check `deadline.expired()` each iteration and break if triggered.
  - For each expensive helper (simulate_trick, base_score adjustments), exit early when `deadline.expired()`.
- `PlayPlannerHard::choose_with_deadline` replaces the existing `choose` function:
  - Construct `Budget` with `time_cap_ms = deadline.remaining_ms().unwrap_or(default_cap)` and keep environment overrides as upper bounds.
  - Add `deadline.check_cancel()` inside:
    - Candidate enumeration loop (`while let Some((idx, (card, base))) = iter.next()` at `crates/hearts-app/src/bot/search.rs:195-260`).
    - Continuation rollouts (`Self::rollout_current_trick`, `self.rollout_next_trick`, etc.).
    - Any `while` loop gated by `budget.should_stop()` to also exit when `deadline.expired()` is true.
  - On cancellation, return the best `(card, score)` seen; if none, return `None` so the UI can fall back.
- Update `Budget::timed_out` to consider both the deterministic step cap and the absolute deadline from UI.
- Update telemetry (`crates/hearts-app/src/telemetry.rs`) to record `think_elapsed_ms`, `timed_out`, and `fallback` for later analysis.

### 5. UI Rendering (status bar and hint bar)
- `WM_SETCURSOR`: add a fast path at the top of `window_proc` that checks `state.thinking`. If present, call `SetCursor(state.cursor_wait)` and return `TRUE`; otherwise defer to `DefWindowProc` behaviour.
- `AppState::status_header_text()`:
  - Idle: reuse `controller.status_text()`.
  - Thinking: format `"North is thinking... 4s (Round 5, Passing: Across, Leader: West)"` using ASCII punctuation.
  - Timed-out result on the previous tick: append `" - timed out, applying fallback"` once by consulting `timeout_banner`.
- `AppState::hint_text()` overrides the bottom hint while `thinking` is active:
  - Show `"North is thinking... 4s so far. Maximum 10s."` (substitute configured duration, omit the sentence when unlimited).
  - If a timeout happened last tick, add `" Using timeout fallback."` to the hint for one frame to acknowledge the event.
  - When idle, fall back to the existing hints (passing instructions, click guidance).
- Both helper methods should call `controller.think_config()` for the current limit so the messaging matches the menu selection.

### 6. Timeout Configuration and Persistence
- Add a new submenu under Game > Options named `Thinking Limit` with radio commands:
  - `ID_OPTIONS_THINK_LIMIT_5` (5s), `ID_OPTIONS_THINK_LIMIT_10` (10s, default), `ID_OPTIONS_THINK_LIMIT_15` (15s), `ID_OPTIONS_THINK_LIMIT_NONE` (no limit).
- Optional advanced submenu `Thinking Fallback` (future work). For now we store `TimeoutFallback` alongside the limit but expose only the default choice in UI.
- Registry integration (`crates/hearts-app/src/platform/win32.rs:3235-3385`):
  - New value `REG_VALUE_THINK_LIMIT` storing milliseconds as `u32` (0 = unlimited).
  - New value `REG_VALUE_THINK_FALLBACK` storing the enum discriminant (default `0` for `HeuristicBest`).
- `AppState::new` reads both values, seeds `ThinkConfig`, and calls `controller.set_think_config(config)`.
- Menu handlers update the config, persist it, refresh the checked radio item, and invalidate the window so messaging updates immediately.

### 7. Logging and Telemetry
- Use `debug_out` for:
  - Think job start: `"think start seat=North limit=10s"`.
  - Think completion: `"think done seat=North elapsed=3.4s timeout=false fallback=None"`.
  - Timeout cancellation: `"think timeout seat=North elapsed=10.1s fallback=HeuristicBest"`.
- Extend `telemetry::hard` to capture elapsed time, timeout flag, and fallback used per bot move.
- Ensure logs execute on the UI thread to avoid multi-threaded access to Win32 logging APIs.

### 8. Cleanup and Shutdown
- `cancel_thinking(reason)` implementation:
  - If `thinking` is `None`, return immediately.
  - Set `cancel` flag.
  - Drain the receiver with `try_recv`; if it returns a result, process it (unless the caller requested an abort, in which case discard after logging).
  - If still active, wait up to three timer ticks (roughly 48 ms) by storing a `cancel_deadline` and checking inside WM_TIMER. After that window, drop the handle and log a warning; this prevents shutdown hangs.
- Call `cancel_thinking` from WM_DESTROY before tearing down Direct2D resources to ensure background threads cannot outlive the window.

### 9. Dependency Impact
- No third-party crates are required; the worker uses `std::thread` and `std::sync::mpsc`.
- Ensure `BotThinkRequest`, `BotSnapshot`, and any helper types derive `Send` + `Sync` (when needed) so background threads compile cleanly.

## Data Flow Summary
1. WM_TIMER sees that the next turn belongs to a bot and no think job is running, so `start_thinking_if_needed` spawns a worker.
2. The UI immediately flips to the wait cursor and updates status/hint text with `"...0s"` messaging.
3. Each WM_TIMER tick updates the elapsed seconds. If a result arrives, the UI applies the move, triggers animations, and clears `thinking`.
4. If the deadline expires first, the cancel flag is set, a timeout banner is latched, and the fallback path is executed once a result (or lack thereof) returns.
5. After animations complete, WM_TIMER resumes scanning for the next seat exactly as before.

## Edge Cases and Compatibility
- Passing phase: `start_thinking_if_needed` returns early, preserving the existing flow for pass animations.
- Human input during think: mouse clicks are ignored with a subtle hint note; ESC cancels pending pass selection as today.
- Unlimited limit (0): workers still run off-thread so the cursor feedback works, but `deadline` is `None`, so planners just respect the cancel flag.
- WinUI host: add a TODO to mirror the menu wiring; ensure the core logic compiles behind the `winui-host` feature even if the menu is not yet exposed.
- CLI build: `GameController::autoplay_one` stays available for non-UI code paths.

## Risks and Mitigations
- **Planner loops ignoring cancel:** instrument the loops listed in Section 4 and add regression tests with artificial delays to prove cancellation works.
- **Thread leaks on shutdown:** `cancel_thinking` plus WM_DESTROY cleanup ensures the window does not close while a worker is still running.
- **Snapshot drift:** compare `controller.expected_to_play()` before applying a worker result; discard mismatched results and reset the hint banner.
- **Performance hit from cloning state:** measure elapsed time against the old synchronous path; if cloning dominates, plan follow-up optimisations (e.g., shallow snapshots or worker pooling).

## Testing Strategy
- Unit tests for `prepare_bot_think` to verify legal move extraction and enforcement of the Two of Clubs rule.
- Unit tests for `ThinkDeadline` and planner cancellation using deterministic fake planners that sleep beyond the deadline.
- Integration tests (Windows) covering:
  - Wait cursor and status/hint updates at different limits.
  - Menu persistence across sessions (registry read/write).
  - Timeout fallback behaviour by configuring a very small limit.
- Manual QA: start a new game, trigger a restart during thinking, and confirm the worker cancels without double-playing.

## Open Questions
- Should we expose the timeout fallback choice in the UI immediately, or keep it as a registry-only tweak for now?
- In unlimited mode, should the wait cursor remain, or would that annoy players during multi-second AI turns?
- Do we need a visual indicator beyond text (e.g., spinner icon) in a future iteration?
