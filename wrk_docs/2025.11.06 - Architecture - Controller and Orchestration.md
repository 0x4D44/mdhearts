# Controller and Game Orchestration Architecture

**Date:** 2025-11-06  
**Focus:** Controller layer architecture, game state management, and orchestration patterns

## Executive Summary

The `GameController` in `crates/hearts-app/src/controller.rs` serves as the central orchestration layer for the MDHearts application. It coordinates game state, AI decision-making, state tracking, and integration between the core game logic (`hearts-core`), bot AI (`bot` module), telemetry, and platform UI layers. The controller implements a clean separation between game logic and presentation, managing concurrent bot thinking, timeout handling, and progressive game flow.

---

## 1. Controller Architecture

### 1.1 Core Structure

```rust
pub struct GameController {
    match_state: MatchState,           // From hearts-core
    last_trick: Option<TrickSummary>,  // For UI display
    bot_difficulty: BotDifficulty,     // AI strength setting
    unseen_tracker: UnseenTracker,     // Card/void tracking
    think_config: ThinkConfig,         // Timeout & fallback config
}
```

**Key Responsibilities:**
- Owns the canonical MatchState (from hearts-core)
- Tracks unseen cards and suit voids via UnseenTracker
- Manages bot difficulty and thinking time limits
- Provides snapshot/context APIs for bot decision-making
- Handles trick completion and moon-shooting state transitions

### 1.2 Initialization Patterns

**Constructors:**
- `new_with_seed(seed: Option<u64>, starting: PlayerPosition)` - Primary constructor
- `new_from_match_state(match_state: MatchState)` - For resuming from saved state

**On initialization:**
1. Creates MatchState with seeded RNG for deterministic games
2. Initializes UnseenTracker and resets for current round
3. Loads bot difficulty and think config from environment variables
4. Resets telemetry counters
5. Logs AI configuration via debug output

---

## 2. Game State Management

### 2.1 State Ownership

The controller delegates core game rules to `hearts-core::MatchState`, which owns:
- Round state (RoundState) - hands, tricks, passing phase
- Score board (ScoreBoard) - cumulative scores
- RNG state for deterministic card dealing

**Controller augments this with:**
- UnseenTracker - probabilistic beliefs about unseen cards
- last_trick - snapshot for UI animations
- Moon state heuristics (per-seat MoonState)

### 2.2 State Query APIs

**Public query methods:**
- `match_over() -> bool` - checks if any player >= 100 points
- `match_winner() -> Option<PlayerPosition>` - identifies winner
- `in_passing_phase() -> bool` - true if awaiting pass selections
- `expected_to_play() -> PlayerPosition` - next player to act
- `legal_moves(seat) -> Vec<Card>` - validates playable cards
- `hand(seat) -> Vec<Card>` - returns player's current hand
- `trick_plays() -> Vec<(PlayerPosition, Card)>` - current trick state
- `standings() -> [u32; 4]` - cumulative scores
- `penalties_this_round() -> [u8; 4]` - round penalties


### 2.3 State Transitions

**Playing a Card:**

The `play()` method coordinates card playing with multiple side effects:

1. Snapshot current trick plays (for void detection)
2. Delegate to `round.play_card(seat, card)` for rule validation
3. On success:
   - Update unseen_tracker with revealed card
   - Detect and record suit voids (if player did not follow suit)
4. On trick completion (`PlayOutcome::TrickCompleted`):
   - Update tracker with trick outcome
   - Store TrickSummary for UI
   - Run moon state heuristics (`update_moon_states_after_trick`)
5. Return outcome (partial trick or trick completed)

**Passing Phase:**
- `submit_pass(seat, cards: [Card; 3])` - records pass selection
- `resolve_passes()` - delegates to round state, transitions to playing

**Round Completion:**
- `finish_round_if_ready()` - checks if 13 tricks complete
- Applies penalties to scores, checks for match winner
- Starts new round or freezes state if match over
- Resets unseen_tracker and clears telemetry

---

## 3. Bot Decision Integration

### 3.1 Asynchronous Thinking Model

**Preparation (main thread):**
`prepare_bot_think(&self, seat) -> Option<BotThinkRequest>`

- Returns None if not bot's turn or in passing phase
- Creates thread-safe BotSnapshot (clones UnseenTracker with fresh cache)
- Packages legal moves, difficulty, and ThinkConfig
- Records pre-decision telemetry

**Execution (worker thread):**
- Platform spawns thread via `spawn_bot_worker`
- Worker calls `PlayPlanner::choose_with_limit` or `PlayPlannerHard::choose_with_limit`
- DecisionLimit wraps deadline + cancellation flag
- Returns BotThinkResult with card, elapsed time, timeout status

**Application (main thread):**
`apply_bot_move(&mut self, seat, card)` validates and executes via `play()`

### 3.2 Timeout and Fallback Handling

**ThinkConfig:**
- `max_duration: Duration` (default 10s)
- `fallback: TimeoutFallback` enum

**TimeoutFallback options:**
- `HeuristicBest` - use fast heuristic planner (default)
- `FirstLegal` - pick first legal card
- `SkipAndLog` - return None, log timeout (test mode)

### 3.3 Autoplay (Synchronous AI)

`autoplay_one(&mut self, stop_seat) -> Option<(PlayerPosition, Card)>`

**Use case:** UI automation for non-human players  
**Flow:**
1. Skip if in passing phase or stop_seat's turn
2. Enforce 2♣ rule on first trick
3. Check if bot style warrants moon commitment
4. Call planner with optional time limit
5. Record telemetry (pre/post decision)
6. Apply fallback if timeout
7. Execute chosen card via `play()`
8. Return (seat, card) or None

---

## 4. State Coordination Mechanisms

### 4.1 UnseenTracker Integration

The UnseenTracker (`bot/tracker.rs`) maintains:
- Set of unseen cards (initially 52, shrinks as cards revealed)
- Per-seat suit voids (bool array per seat)
- Per-seat MoonState (Inactive/Considering/Committed)
- Per-seat BeliefState with probability distributions
- Belief cache (keyed by round fingerprint) for memoization

**Updates:**
- `note_card_played(seat, card)` - removes card from unseen set
- `note_void(seat, suit)` - marks suit void, updates beliefs
- `note_trick_completion(...)` - infers voids, updates moon likelihoods
- `set_moon_state(seat, state)` - explicit moon state transition

**Cache:**
- Thread-safe `Arc<RwLock<BeliefCache>>` for belief snapshots
- Keyed by trick history fingerprint
- Tracks hit/miss metrics for telemetry

### 4.2 Moon State Heuristics

**Stage 2 moon detection** (in `update_moon_states_after_trick`):

**Commit conditions:**
- Winner of clean (0-point) trick early in round
- Tricks won >= threshold (default 2)
- Hearts in hand >= 5, control hearts (10+ rank) >= 3
- Current score < 70, cards played <= 20
- Transitions: Inactive → Considering → Committed

**Abort conditions:**
- Opponents collected >= 3 hearts
- Lost control (non-winner of clean trick)
- Near end-game (cards played >= 36)
- Too few hearts left (< 3)
- Configurable via env vars (`MDH_MOON_*`)

### 4.3 Telemetry and Observability

**Pre-decision telemetry:**
- Called in `prepare_bot_think` and `autoplay_one`
- Records: seat, belief entropy, cache metrics, difficulty

**Post-decision telemetry:**
- Records: elapsed time, timeout status, fallback mode

**Export:**
- `crate::telemetry::hard::export(path)` - writes NDJSON
- Enforces retention policy
- CLI: `--show-hard-telemetry --out <path>`


---

## 5. Integration Patterns

### 5.1 Platform Layer (UI)

**Win32 Platform (`platform/win32.rs`):**
- Owns AppState struct containing GameController
- Spawns bot thinking threads via `spawn_bot_worker`
- Polls worker results in message loop timer ticks
- Manages animations (PlayAnim, CollectAnim, PassAnim)
- Handles user input (card clicks, menu selections)

**State synchronization:**
- Controller is single-threaded (main UI thread owns it)
- Bot workers operate on cloned snapshots (`BotSnapshot::make_thread_local`)
- Results communicated via `mpsc::Receiver<BotThinkResult>`
- Cancellation via `Arc<AtomicBool>` checked in planner loops

### 5.2 Core Game Logic (hearts-core)

**Delegation pattern:**
- Controller wraps `hearts-core::MatchState`
- All rule enforcement delegated to `RoundState::play_card`
- Controller adds: void inference, moon state tracking, telemetry, snapshot APIs

**No direct mutation:** UI never touches MatchState directly - always via controller methods.

### 5.3 Bot Module (bot/*)

**Modularity:**
- PlayPlanner (heuristic)
- PlayPlannerHard (search-based)
- PassPlanner (passing selection)
- UnseenTracker (beliefs)
- adviser (bias adjustments)
- search (lookahead engine)

**BotContext struct:**
Provides immutable references to game state for bot planners.

**Controller provides:**
- `bot_context(seat) -> BotContext` - borrows references for bot planners
- `simple_pass_for(seat) -> Option<[Card; 3]>` - delegates to PassPlanner

---

## 6. Match/Round/Trick Flow Control

### 6.1 Match Flow

```
MatchState::new(starting_player)
  ↓
GameController::new_with_seed(seed, starting)
  ↓
[Passing Phase] → submit_pass() × 4 → resolve_passes()
  ↓
[Playing Phase] → play() until 13 tricks complete
  ↓
finish_round_if_ready()
  ↓
(if match_over) match_winner()
  ↓
(else) start next round with new passing direction
```

### 6.2 Passing Phase Flow

1. Round starts in `RoundPhase::Passing` if not "Hold" direction
2. Each player selects 3 cards via `submit_pass(seat, cards)`
3. Controller updates tracker: `note_pass_selection(seat, cards)`
4. Once all 4 submitted, call `resolve_passes()`
5. Core swaps cards between hands, transitions to Playing phase

### 6.3 Playing Phase Flow

**Per trick:**
1. Leader determined by `current_trick().leader()`
2. Each of 4 players plays in turn
3. On 4th play: trick completes
   - Winner determined by core rules
   - last_trick stored for UI
   - Moon heuristics run
   - Tracker updated with voids/penalties
4. Next trick starts with winner as leader

**After 13 tricks:**
- `is_round_ready_for_scoring() == true`
- UI calls `finish_round_if_ready()`
- Penalties applied, scores updated
- If match over: state frozen for review
- Else: new round dealt, tracker reset

---

## 7. Player Action Handling

### 7.1 Human Player Actions

**Card Play:**
- UI detects click on card in hand
- Checks if card in `legal_moves(PlayerPosition::South)`
- Calls `controller.play(PlayerPosition::South, card)`
- On success: UI starts play animation
- On error: shows validation message

**Passing:**
- UI allows selecting 3 cards
- On confirm: calls `submit_pass` and `submit_auto_passes_for_others`
- Calls `resolve_passes()`
- UI animates pass exchange

### 7.2 Bot Player Actions

**Synchronous (autoplay):**
- Main thread calls `autoplay_one(PlayerPosition::South)` in timer tick
- Returns `Some((seat, card))` if bot played
- Returns None if human turn or timeout with skip fallback

**Asynchronous (UI worker):**
1. Timer tick checks if bot turn
2. Calls `prepare_bot_think(seat)` → returns BotThinkRequest
3. Spawns worker thread with cancel flag
4. Worker executes planner with deadline
5. Main thread polls `rx.try_recv()` for result
6. On timeout: shows banner, applies fallback
7. On result: calls `apply_bot_move(seat, card)`

---

## 8. State Validation and Error Handling

### 8.1 Validation Points

**Legal move validation:**
- `legal_moves(seat)` probes `round.clone().play_card(seat, card)` for each card
- Filters to only cards that return `Ok(_)`

**Play validation:**
- `play()` delegates to `round.play_card()` which enforces:
  - Two of clubs on first trick
  - Following suit if possible
  - No points on first trick (unless all points)
  - Hearts broken rule

**Passing validation:**
- `submit_pass()` validates exactly 3 cards, cards in hand, not already submitted

### 8.2 Error Recovery

**PlayError handling:**
- Controller propagates PlayError from core
- UI shows error dialog or logs
- State unchanged on error (transaction safety)

**Timeout recovery:**
- Worker thread timeout triggers fallback
- Fallback card chosen via heuristic or first legal
- Telemetry records timeout event

**Panic handling:**
- Application installs global panic hook (`main.rs`)
- Writes backtrace to log file
- Shows message box on Windows

---

## 9. Threading and Concurrency

### 9.1 Threading Model

**Main thread (UI):**
- Owns GameController (single-threaded, not Send)
- Processes user input
- Runs animations
- Polls bot worker results

**Bot worker threads:**
- Short-lived (one per bot decision)
- Receives cloned BotSnapshot
- No shared mutable state except cancellation flag and result channel

### 9.2 Synchronization Primitives

**Cancellation:**
- `Arc<AtomicBool>` checked in planner loops
- UI can cancel on window close or new game

**Result channel:**
- `mpsc::channel` (one-shot per worker)
- Main thread polls `rx.try_recv()` in timer tick

**Belief cache:**
- `Arc<RwLock<BeliefCache>>` in UnseenTracker
- Thread-safe for concurrent access

### 9.3 Thread Safety Notes

- GameController is NOT `Send` or `Sync` (owns raw COM pointers on Windows)
- BotSnapshot is `Clone` and produces thread-local cache
- Telemetry sink uses `RwLock` for concurrent append

---

## 10. Configuration and Environment Variables

### 10.1 Bot Configuration

**Difficulty:**
- `MDH_BOT_DIFFICULTY` = easy|normal|hard|search
- Default: NormalHeuristic

**Think Limits:**
- `MDH_THINK_LIMIT_MS` = milliseconds (0 = unlimited)
- `MDH_THINK_FALLBACK` = heuristic_best|first_legal|skip_and_log
- Default: 10s, heuristic_best

**Weights:**
- `MDH_PLANNER_*` env vars (loaded by `bot/play.rs`)
- `MDH_HARD_*` env vars (loaded by `bot/search.rs`)

### 10.2 Moon Heuristics

**Commit gates:**
- `MDH_MOON_COMMIT_MAX_CARDS` = 20
- `MDH_MOON_COMMIT_MAX_SCORE` = 70
- `MDH_MOON_COMMIT_MIN_TRICKS` = 2
- `MDH_MOON_COMMIT_MIN_HEARTS` = 5
- `MDH_MOON_COMMIT_MIN_CONTROL` = 3

**Abort gates:**
- `MDH_MOON_ABORT_OTHERS_HEARTS` = 3
- `MDH_MOON_ABORT_NEAREND_CARDS` = 36
- `MDH_MOON_ABORT_MIN_HEARTS_LEFT` = 3
- `MDH_MOON_ABORT_LOST_CONTROL` = true

### 10.3 Telemetry

- `MDH_HARD_TELEMETRY_KEEP` = retention count (default 20)
- `MDH_DEBUG_LOGS` = 1|true|on (enables OutputDebugString on Windows)


---

## 11. Testing Support

### 11.1 Test-Only APIs

Test-only methods marked with `#[cfg(test)]`:
- `configure_for_test(&mut self)`
- `set_round_and_scores_for_test(...)`
- `moon_state_for_test(seat) -> MoonState`
- `current_trick_plays_for_test() -> usize`

### 11.2 Test Patterns

**Deterministic replay:**
- Use `new_with_seed(Some(fixed_seed), starting)`
- Verify same card deals and outcomes

**Moon state testing:**
- Set up specific hands via `set_round_and_scores_for_test`
- Play scripted tricks
- Assert moon state transitions via `moon_state_for_test`

**Timeout testing:**
- `MDH_TEST_FORCE_AUTOP_TIMEOUT=1` forces immediate timeout
- Verifies fallback logic without waiting

**Extensive unit tests:**
- controller.rs has 11 tests covering difficulty modes, 2♣ enforcement, moon flows, timeouts, and passing

---

## 12. Key Design Patterns

### 12.1 Delegation

- Controller delegates game rules to hearts-core
- Controller delegates AI decisions to bot module
- Controller delegates rendering to platform layer

### 12.2 Snapshot Isolation

- Bot workers receive immutable snapshots
- Workers never mutate controller state
- Results applied atomically in main thread

### 12.3 Hook Points

- Pre/post decision telemetry
- Moon state updates on trick completion
- Void inference on illegal suit follows
- Animation triggers via last_trick

### 12.4 Fail-Safe Defaults

- Empty legal moves → None
- Timeout → fallback (never deadlock)
- Missing config → sensible defaults
- Invalid env vars → ignored

### 12.5 Single Responsibility

- GameController: orchestration and coordination
- MatchState: game rules and state
- UnseenTracker: probabilistic beliefs
- PlayPlanner: heuristic AI
- PlayPlannerHard: search-based AI

---

## 13. Performance Characteristics

### 13.1 Time Complexity

- `legal_moves(seat)`: O(hand_size × validate_cost) ≈ O(13 × 10) = O(130)
- `play(seat, card)`: O(1) core logic + O(1) tracker updates
- `autoplay_one()`: O(13 × heuristic_cost)
  - Heuristic: ~1-5ms typical
  - Search: up to time limit (5-15s configurable)

### 13.2 Space Complexity

- GameController: ~10KB (excluding bitmaps)
- UnseenTracker: ~2KB + belief cache (~512KB)
- BotSnapshot: cloned state ~5KB per worker

### 13.3 Optimization Notes

- Legal move validation uses cheap RoundState clones
- Belief cache memoizes expensive entropy calculations
- Thread-local cache in workers avoids lock contention
- Telemetry buffered in-memory, flushed on export

---

## 14. Future Extension Points

### 14.1 Multiplayer

- Controller currently single-player (South = human, others = bots)
- Extension: add player roles (Human | Bot | Remote)
- Network layer would send `play(seat, card)` across wire
- Controller validates all moves regardless of source

### 14.2 Replay/Undo

- Controller owns linear state (no undo stack currently)
- Extension: add MatchHistory with snapshots per move
- Undo: restore previous snapshot
- Replay: iterate snapshots with animation

### 14.3 Analytics

- Telemetry currently records belief entropy and search metrics
- Extension: add move regret analysis (compare chosen vs optimal)

### 14.4 AI Tuning

- Current weights loaded from env vars
- Extension: add UI for weight sliders
- Persist to registry or config file

---

## 15. Critical Invariants

1. **Single ownership:** Main thread owns controller; workers own snapshots
2. **Immutable snapshots:** Workers never mutate original state
3. **Atomicity:** Move application is all-or-nothing
4. **Legality:** All plays validated by core before state mutation
5. **Tracker consistency:** Unseen set always matches cards not yet played
6. **Moon state consistency:** Transitions only on trick completion
7. **No blocking:** Worker threads never block main thread (polling model)
8. **Telemetry opt-in:** Zero overhead if not exported

---

## 16. Common Pitfalls and Gotchas

1. **Thread lifetime:** Worker handle must be joined or detached before dropping ThinkingState
2. **Cache invalidation:** Belief cache keyed by trick history; don't replay old snapshots
3. **Void inference:** Only recorded on actual illegal follows
4. **Moon abort timing:** Abort checks run after trick completes
5. **Passing vs playing:** Always check `in_passing_phase()` before calling play APIs
6. **Timeout precision:** Deadline checked between candidates (can overshoot slightly)
7. **DPI scaling:** Layout calculations in platform layer must account for DPI

---

## 17. Related Documentation

- **Core Logic:** `hearts-core/src/model/round.rs` - game rules
- **Bot AI:** `crates/hearts-app/src/bot/` - AI implementation
- **Telemetry:** `crates/hearts-app/src/telemetry.rs` - metrics and export
- **Platform:** `crates/hearts-app/src/platform/win32.rs` - UI integration
- **CLI:** `crates/hearts-app/src/cli.rs` - command-line tools

---

## 18. Key Algorithms

### 18.1 Void Inference

When a card is played that does not match the lead suit:
1. Check if player had cards of lead suit
2. If not following suit and did not have suit → mark void
3. Update BeliefState to set all cards of that suit to 0 probability for that seat

### 18.2 Moon State Progression

State machine per seat:
- **Inactive:** Default state, no moon attempt
- **Considering:** Won 1+ clean tricks, has good hearts, not yet committed
- **Committed:** Won 2+ clean tricks with excellent holdings, actively pursuing moon
- **Abort to Inactive:** Lost control, opponents took hearts, or end-game approached

Transitions checked after every trick completion.

### 18.3 Legal Move Computation

For each card in hand:
1. Clone current RoundState
2. Attempt `round.play_card(seat, card)`
3. If `Ok(_)`, card is legal
4. If `Err(_)`, card violates rules
5. Collect all Ok cards as legal set

This uses Hearts core's complete rule validation without duplicating logic.

---

## 19. Revision History

- **2025-11-06:** Initial architecture documentation based on comprehensive code exploration

---

**End of Document**

