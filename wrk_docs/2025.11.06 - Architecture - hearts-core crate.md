# Hearts-Core Crate Architecture

**Date:** 2025.11.06

**Crate:** `crates/hearts-core/`  
**Purpose:** Deterministic game rules and core logic layer for the Hearts card game

## Overview

The `hearts-core` crate is the foundational layer of the mdhearts application, implementing the complete game logic for Hearts in a purely deterministic manner. It contains no I/O, no UI concerns, and no AI/strategy logic - only the rules, state management, and validation required to play a correct game of Hearts.

### Key Responsibilities
- Card and deck representation
- Player position and turn management  
- Hand management with automatic sorting
- Passing phase logic (Left/Right/Across/Hold)
- Trick-taking mechanics with suit following enforcement
- Round state transitions and validation
- Score tracking with Shooting the Moon logic
- Match state management across multiple rounds
- Serialization/deserialization for game persistence

### Design Philosophy
- Zero tolerance for invalid game states (strict validation)
- Immutable-friendly where possible, mutable where necessary
- Comprehensive unit test coverage
- Type-safe representation of game concepts
- Deterministic shuffle via seeded RNG

## Crate Structure

```
crates/hearts-core/
├── src/
│   ├── lib.rs              # Public API root, AppInfo metadata
│   ├── model/              # Core data structures
│   │   ├── card.rs         # Card representation
│   │   ├── rank.rs         # Rank enum (2-Ace)
│   │   ├── suit.rs         # Suit enum (Clubs/Diamonds/Spades/Hearts)
│   │   ├── deck.rs         # 52-card deck with deterministic shuffle
│   │   ├── hand.rs         # Player hand with auto-sort
│   │   ├── player.rs       # PlayerPosition enum (N/E/S/W)
│   │   ├── passing.rs      # Passing direction and state
│   │   ├── trick.rs        # Single trick state and winner logic
│   │   ├── score.rs        # ScoreBoard with Shoot the Moon
│   │   └── round.rs        # RoundState with complete game rules
│   └── game/               # Higher-level game coordination
│       ├── match_state.rs  # Multi-round match management
│       └── serialization.rs # JSON persistence layer
└── Cargo.toml
```

## Module-by-Module Analysis

### `lib.rs` - Crate Root
- **Public API:** `pub mod game; pub mod model;`
- **AppInfo:** Static metadata (name="mdhearts", codename="Rust Remaster", version)
- **Compiler:** `#![deny(warnings)]` - zero tolerance for warnings

### `model/rank.rs` - Card Ranks
- **Type:** `Rank` enum: Two(2) through Ace(14)
- **Features:** `ORDERED` constant, `from_value()`, `value()`
- **Design:** Ace = 14 for trick-winning logic, implements Ord

### `model/suit.rs` - Card Suits  
- **Type:** `Suit` enum: Clubs(0), Diamonds(1), Spades(2), Hearts(3)
- **Features:** `ALL` constant, `is_heart()`, `is_black()`
- **Design:** Hearts highest for ordering

### `model/card.rs` - Playing Cards
- **Type:** `Card { rank, suit }` - Copyable 16-bit struct
- **Methods:** `is_penalty()`, `is_queen_of_spades()`, `penalty_value()`
- **Rules:** Hearts = 1 pt, Queen of Spades = 13 pts, others = 0

### `model/deck.rs` - Standard Deck
- **Purpose:** 52-card deck generation with **deterministic shuffling**
- **Key Method:** `shuffled_with_seed(u64)` - same seed → same order
- **Implementation:** Uses `rand::rngs::StdRng` for reproducibility


### `model/hand.rs` - Player Hands
- **Features:** Auto-sorted by suit then rank
- **Methods:** `add()`, `remove()`, `contains()`, `cards()`, `iter()`
- **Invariant:** Maintains sort automatically on every add

### `model/player.rs` - Player Positions
- **Type:** `PlayerPosition`: North/East/South/West (0-3)
- **Methods:** `next()` (clockwise), `previous()`, `opposite()`  
- **Usage:** Array indices throughout: `hands[seat.index()]`
- **Constant:** `LOOP` for iteration over all players

### `model/passing.rs` - Card Passing Phase
- **PassingDirection:** Left/Right/Across/Hold cycle
- **PassingState:** Tracks 3-card submissions per player
- **Flow:** `submit()` removes from hand, `apply()` distributes to targets
- **Validation:** Prevents passing cards you don't have

### `model/trick.rs` - Single Trick
- **Type:** `Trick` = leader + up to 4 plays
- **Play:** `{ position, card }`
- **Winner:** Highest rank of **lead suit only** (off-suit cards cannot win)
- **Scoring:** `penalty_total()` sums penalty values

### `model/score.rs` - Score Tracking
- **Type:** `ScoreBoard` with totals `[u32; 4]`
- **Core Logic:** `apply_hand(penalties: [u8; 4])`:
  - If one player takes all 26 points: Shoot the Moon - opponents get 26 each
  - Otherwise: Normal penalty assignment
- **Goal:** Lowest score wins (golf scoring), match ends at ≥100 points

### `model/round.rs` - Round State ⭐ **MOST COMPLEX MODULE**

**Implements the complete Hearts ruleset**

- **RoundState:** hands, current_trick, trick_history, phase, hearts_broken
- **RoundPhase:** `Passing(PassingState)` or `Playing`
- **deal():** Distributes 52 cards (13 each), finds 2♣ holder
- **play_card():** Enforces ALL Hearts rules:
  1. Phase check (must be in Playing phase)
  2. Hand check (player must have the card)
  3. Turn order validation (clockwise from leader)
  4. First trick: must lead 2♣
  5. First trick: no points (hearts/Q♠) unless unavoidable
  6. Follow suit requirement (if possible)
  7. Cannot lead hearts until broken (or only hearts in hand)
  8. Updates state, returns `PlayOutcome`

**Hearts Rules Summary:**
- Deal: 13 cards each, 2♣ holder starts
- Passing: 3 cards in Left/Right/Across/Hold cycle
- First lead: Must play 2♣
- First trick: No penalty cards unless unavoidable
- Follow suit: Mandatory if possible
- Hearts leading: Not allowed until hearts broken
- Winner: Highest card of lead suit
- Penalties: Winner of trick takes penalty points


### \ - Multi-Round Match Management
- **MatchState:** scores, round, RNG, seed, round_number, passing_index
- **Manages:** Multiple rounds with deterministic RNG state
- **Determinism:** Same seed → same deck sequence across all rounds
- **finish_round_and_start_next():**
  - Applies round penalties to scoreboard
  - Checks for match end (any player ≥100)
  - Returns winner (lowest score) or starts next round
  - Advances passing cycle, rotates starting player
- **RNG Advancement:** Correctly handles round number skipping for reproduction

### \ - JSON Persistence
- **MatchSnapshot:** seed, round_number, passing_direction, scores, round_starting_player
- **Methods:** \, \, \, - **NOT Stored:** current hands, trick history, RNG internal state
- **Rationale:** Deterministic deck generation minimizes JSON size, seed reproduces everything

---

## Key Algorithms

**Trick Winner Determination:**
**Shoot the Moon Detection:**
**Follow Suit Validation:**
**Hearts Breaking:**
**Deterministic Shuffling:**
---

## Public API Design Patterns

- **Const Constructors:** \, \ - compile-time evaluation
- **Result-Based Validation:** - **Enum State Machines:** - **Array Indices:** \ instead of HashMap
- **Deterministic Seeds:** Same seed → same game (reproducibility)
- **Constant Iterators:** - **One-Time Consumption:** \ consumes self

---

## Invariants and Constraints

### Type-Enforced
- 4 players (all arrays are \)
- 52 cards in deck (construction logic)
- 13 cards per hand (dealing logic)
- 4 plays per trick (validation)
- 3 cards per pass (\)
- Circular turn order (PlayerPosition::next() wraps)

### Validation-Enforced
- Card must be in hand before playing
- Must follow suit if possible
- Turn order (clockwise from leader)
- First trick rules (2♣ lead, no points)
- Hearts leading restriction (until broken)
- Pass completeness (all 4 players)
- Phase consistency (no play during passing, no pass during playing)

### Code-Maintained
- Hand sorting (automatic on add/with_cards)
- Hearts broken flag (set when any heart played)
- Trick history (immutable Vec, append-only)
- Score accumulation (only via ScoreBoard methods)
- Deterministic RNG state (preserved between rounds)

---

## Notable Implementation Details

- **Zero-Copy Types:** `Card`, `PlayerPosition`, `Rank`, `Suit` are all `Copy` (small enums/structs)
- **No Panics in Public API:** All methods validated, return `Result` or `Option`
- **Comprehensive Testing:** Unit tests in every module (18 tests in round.rs alone)
- **Bounded Sizes:** Max 13 cards per hand, max 13 tricks per round
- **Rust 2024 Edition:** Uses latest language features (let-else, etc.)
- **Dependencies:**
  - `rand = "0.8"`: Deterministic shuffling via StdRng
  - `serde = "1.0"`: JSON serialization
  - `serde_json = "1.0"`: Human-readable persistence

---

## Usage Examples

**Starting a New Match:**
**Playing a Card:**
**Passing Cards:**
**Finishing a Round:**
**Serialization:**


---

## External Code Integration

**Expected Usage Pattern:**
1. UI layer reads game state (hands, tricks, scores)
2. AI layer queries legal moves, chooses cards
3. Input handler calls play_card/submit_pass
4. Game loop checks phases, advances rounds
5. Persistence uses serialization

**This Crate Does NOT:**
- Render UI components
- Handle network communication
- Implement AI/bot strategy
- Perform file I/O (except via serde_json)
- Provide async/concurrency primitives

**Extension Points:**
- AI can clone MatchState for lookahead (all state is Clone)
- Custom scoring variants could extend ScoreBoard
- Modified penalty values via Card::penalty_value()
- Network action serialization (future feature)

---

## Design Decisions and Rationale

**Deterministic Shuffling:**
- Reproducibility for debugging
- Predictable tests (same seed = same game)
- AI training on exact scenarios
- Fairness verification

**Immutable Trick History:**
- Full game audit trail
- Potential undo/replay features
- AI can analyze past plays
- Debugging support

**Separate Passing/Playing Phases:**
- Clear state machine
- Enforces all-pass-before-play rule
- UI clarity (different screens)

**Array Indices vs HashMap:**
- Performance (direct indexing)
- Type safety (always 0-3)
- Simplicity (no hashing)
- Cache friendly (contiguous memory)

**Minimal Snapshots:**
- Deterministic seed regenerates everything
- Smaller JSON files
- Easier format evolution
- No cheating possible (verifiable regeneration)

---

## Conclusion

The hearts-core crate is a **complete, deterministic, well-tested implementation of Hearts game rules**.

**It Provides:**
- Type safety for all game concepts
- Comprehensive validation of all rules
- Deterministic behavior for reproducibility
- Clean separation from UI/AI/I/O concerns
- Extensive test coverage for correctness
- Serialization support for persistence

**External Code Can Rely On This To:**
- Enforce all Hearts rules correctly
- Maintain valid game state at all times
- Provide deterministic shuffling for testing/replay
- Support save/load functionality
- Serve as single source of truth for game logic

**Design Priorities:**
1. **Correctness** over performance (though performance is still good)
2. **Clarity** over cleverness
3. **Compile-time safety** over runtime flexibility

The crate successfully achieves its goal of being a pure, deterministic game logic layer with no external dependencies beyond basic serialization and RNG. All Hearts rules are properly enforced, making invalid game states impossible through the public API.
